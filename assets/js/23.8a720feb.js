(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{414:function(e,t,n){"use strict";n.r(t);var a=n(41),o=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"network-api"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#network-api"}},[e._v("#")]),e._v(" Network API")]),e._v(" "),n("p",[e._v('Suitably-empowered code inside a vat can access a "network API" that works\nvaguely like the BSD socket API. This code can:')]),e._v(" "),n("ul",[n("li",[e._v("Open a listening port on various networking stacks.")]),e._v(" "),n("li",[e._v("Initiate connections to remote ports.")]),e._v(" "),n("li",[e._v("Send and receive data over these connections")]),e._v(" "),n("li",[e._v("Finally close the connection and/or ports.")])]),e._v(" "),n("p",[e._v("The type of connection is limited by the host in which the vat is running.\nChain-based machines must operate in a platonic realm of replicated consensus,\nso their network options are limited to protocols like IBC, which allow one\ngestalt chain to talk to other chain-like entities. Each such entity is\ndefined by an evolving set of consensus rules, which typically include a\ncurrent set of validator public keys and a particular history of hashed\nblock identifiers.")]),e._v(" "),n("p",[e._v("["),n("strong",[e._v("CAVEAT:")]),e._v(' IBC uses "Connection" to mean a chain-to-chain "hop", and\n"Channel" to mean a Port-to-Port pathway through a series of hops.\nhttps://github.com/cosmos/ics/blob/master/ibc/1_IBC_TERMINOLOGY.md#connection .\nThis is unfortunate, because IBC "Channels" correspond most precisely to\nTCP "connections", and most discussions of network APIs (including this one,\nbelow) will talk about "connections" extensively.')]),e._v(" "),n("p",[e._v('For now, our IBC implementation can only use pre-established hops, and provides\nno means for user-level code to create new hops (IBC Connections) at runtime.\nBut user-level code can create new IBC Channels at any time. The terminology\nconfusion will be most obvious in the section on "Accepting an Inbound Connection",\nwhere the user code is really accepting an inbound '),n("em",[e._v("IBC Channel")]),e._v(".]")]),e._v(" "),n("p",[e._v("A channel via these IBC hops will terminate in IBC-aware code on either end.\nThese endpoints might be traditional (static) IBC handlers (such as an ICS-20\ntoken transfer module), or dynamic IBC handlers (e.g. running in a SwingSet vat).\nSwingSet vat code that wants to speak to vat code in a different SwingSet machine\nwould not use the IBC connection directly: instead it would simply perform normal\neventual-send operations ("),n("code",[e._v("target~.foo(args)")]),e._v(') and let the "CapTP" promise-pipelining\nlayer handle the details. But vat code which wants to speak to an ICS-20 handler\nin some other chain would need to use this layer.')]),e._v(" "),n("p",[e._v("Vats which live inside a solo machine are able to use traditional networking layers,\nlike TCP, HTTP, and WebSockets. This enables them to communicate with e.g.\nbrowser-side UI frontends that use WebSockets to query the vat for order status.\nThese connections do not have to follow normal ocap rules, so vat code which accept\nthem must provide their own authentication and access control protections.")]),e._v(" "),n("p",[e._v("Solo machines may be able to talk to chains and vice versa using specialized\nprotocols. This will be used by CapTP to provide ocap messaging between these\nheterogeneous machine types.")]),e._v(" "),n("h2",{attrs:{id:"the-agoric-sdk-user-local-port"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#the-agoric-sdk-user-local-port"}},[e._v("#")]),e._v(" The agoric-sdk User Local Port")]),e._v(" "),n("p",[e._v("Each user of the Agoric testnet gets a few personal IBC listening ports. You\ncan access these "),n("code",[e._v("Port")]),e._v(" objects in the "),n("code",[e._v("home.ibcport")]),e._v(" array, and you can learn\ntheir local address by calling something like "),n("code",[e._v("home.ibcport[0]~.getLocalAddress()")]),e._v(",\nwhich will give you a local address like "),n("code",[e._v("/ibc-port/portbvmnfb")]),e._v(".")]),e._v(" "),n("p",[e._v("This is currently the only way for user code to get an IBC "),n("code",[e._v("Port")]),e._v(", though non-IBC\nports can be allocated using the local "),n("code",[e._v("home.network")]),e._v(" object.  This is an advanced\nuse case, to be documented later.")]),e._v(" "),n("h2",{attrs:{id:"connecting-to-a-remote-port"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#connecting-to-a-remote-port"}},[e._v("#")]),e._v(" Connecting to a Remote Port")]),e._v(" "),n("p",[e._v("To establish a connection, you must start with a local "),n("code",[e._v("Port")]),e._v(" object, and you must\nknow the name of the remote endpoint. The remote endpoint will have a name like\n"),n("code",[e._v("/ibc-hop/$HOPNAME/ibc-port/$PORTNAME/ordered/$VERSION")]),e._v(" (where "),n("code",[e._v("ibc-hop")]),e._v(", "),n("code",[e._v("ibc-port")]),e._v("\nand "),n("code",[e._v("ordered")]),e._v(" are literal strings, spelled just like that, but "),n("code",[e._v("$HOPNAME")]),e._v(", "),n("code",[e._v("$PORTNAME")]),e._v(",\nand "),n("code",[e._v("$VERSION")]),e._v(" are placeholders for arbitrary values that will vary from one endpoint\nto another).")]),e._v(" "),n("p",[e._v("You must also prepare a "),n("code",[e._v("ConnectionHandler")]),e._v(" object to manage the connection you're\nabout to create. This has a number of methods which will be called when the things\nhappen to the connection, including packets arriving. This is described below.")]),e._v(" "),n("p",[e._v("Then you will call the "),n("code",[e._v("connect()")]),e._v(" method on your local "),n("code",[e._v("Port")]),e._v(". This will return\na "),n("code",[e._v("Promise")]),e._v(" that will fire with a new "),n("code",[e._v("Connection")]),e._v(" object, on which you can send\ndata. Your "),n("code",[e._v("ConnectionHandler")]),e._v(" will be notified about the new channel, and will\nreceive inbound data from the other side.")]),e._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[e._v("home"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("ibcport"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),n("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("~")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("connect")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("endpoint"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" connectionHandler"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("then")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("conn")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("doSomethingWithConnection")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("conn"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),n("h2",{attrs:{id:"opening-a-listening-port-and-accepting-an-inbound-connection"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#opening-a-listening-port-and-accepting-an-inbound-connection"}},[e._v("#")]),e._v(" Opening a Listening Port and Accepting an Inbound Connection")]),e._v(" "),n("p",[e._v("The other side of "),n("code",[e._v("connect()")]),e._v(' is a "listening port". These ports are waiting for\ninbound connections to be established.')]),e._v(" "),n("p",[e._v("To get a listening port, you need a "),n("code",[e._v("NetworkInterface")]),e._v(" object (such as the one on\nyour "),n("code",[e._v("ag-solo")]),e._v(" under "),n("code",[e._v("home.network")]),e._v(") and ask it to "),n("code",[e._v("bind()")]),e._v(" to an endpoint. You\ncan either provide a specific port name, or allow the API to allocate a random\none for you. The endpoint specifies the type of connection that this port will\nbe able to accept (IBC, TCP, etc), and some properties of that connection. "),n("code",[e._v("bind()")]),e._v('\nuses a "multiaddress" to encode this information.')]),e._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// ask for a random allocation - ends with a slash")]),e._v("\nhome"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("network"),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("~")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("bind")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("'"),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("/")]),e._v("ibc"),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("-")]),e._v("port"),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("/")]),n("span",{pre:!0,attrs:{class:"token template-string"}},[n("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[e._v("`")]),n("span",{pre:!0,attrs:{class:"token string"}},[e._v(")\n  .then(port => usePort(port));\n//\n// or ask for a specific port name\nhome.network~.bind('/ibc-port/my-cool-port-name")]),n("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[e._v("`")])]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("then")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("port")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("usePort")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("port"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),n("p",[e._v('IBC has named "hops" (what they call "Connections" in the IBC spec) which each\ncarry data between two specific chains.  These hops are different from the\nconnections described in this document.  When you bind a port like '),n("code",[e._v("/ibc-port/$PORT")]),e._v('\nwithout specifying the "hop", any IBC chain can initiate a connection to this port.')]),e._v(" "),n("p",[e._v("You can ask the "),n("code",[e._v("Port")]),e._v(" object this returns for its local address, which is especially\nuseful if you had asked for a random allocation (since otherwise you have no way\nto know what address you got):")]),e._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[e._v("port"),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("~")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("getLocalAddress")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("then")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("localAddress")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("useIt")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("localAddress"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])])]),n("p",[n("code",[e._v("home.ibcport[0]~.addListener()")])]),e._v(" "),n("p",[e._v("Once the port is bound, you must call "),n("code",[e._v("addListener")]),e._v(" to mark it as ready for inbound\nconnections. You must provide this with a "),n("code",[e._v("ListenHandler")]),e._v(" object, which has methods\nto react to listening events. As with "),n("code",[e._v("ConnectionHandler")]),e._v(", these methods are all\noptional.")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("onListen(port, handler)")]),e._v(": called when the port starts listening")]),e._v(" "),n("li",[n("code",[e._v("onAccept(port, remote, handler)")]),e._v(": called when a new channel has been accepted")]),e._v(" "),n("li",[n("code",[e._v("onError(port, rejection, handler)")]),e._v(": called if the port is no longer able to accept channels, such as if the Connection to the remote chain has failed, perhaps because a consensus failure was observed")]),e._v(" "),n("li",[n("code",[e._v("onRemove(port, handler)")]),e._v(": called when the "),n("code",[e._v("ListenHandler")]),e._v(" is being removed")])]),e._v(" "),n("p",[e._v("Once your "),n("code",[e._v("ChannelHandler")]),e._v(" is prepared, call "),n("code",[e._v("addListener")]),e._v(":")]),e._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[e._v("port"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("addListener")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("handler"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("then")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" console"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("log")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[e._v("'listener is active'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])])]),n("p",[e._v("Of all the methods, "),n("code",[e._v("onAccept")]),e._v(" is the interesting one. It is called with a "),n("code",[e._v("remote")]),e._v("\nendpoint, which tells you the address of the "),n("code",[e._v("Port")]),e._v(" at the other end, where someone\nelse called "),n("code",[e._v(".connect")]),e._v(". You can use this to decide if you want to accept the\nconnection, or what sort of authority to exercise in response to messages arriving\ntherein.")]),e._v(" "),n("p",[e._v("If you choose to accept, your "),n("code",[e._v("onAccept")]),e._v(" method must return a "),n("code",[e._v("Promise")]),e._v(" that fires\nwith a "),n("code",[e._v("ConnectionHandler")]),e._v(". This will be used just like the one you would pass into\n"),n("code",[e._v("connect()")]),e._v(". To decline, throw an error.")]),e._v(" "),n("h2",{attrs:{id:"sending-data"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#sending-data"}},[e._v("#")]),e._v(" Sending Data")]),e._v(" "),n("p",[e._v('The Networking API (at least for IBC) provides a "record pipe", in which each packet\nis transmitted intact over the network, requiring no additional framing to distinguish\nwhere one packet ends and the next one begins. This is in contrast to the "byte pipe"\nprovided by a TCP connection, where you must typically prepend length headers to\nestablish framing boundaries.')]),e._v(" "),n("p",[e._v("Once you have a "),n("code",[e._v("Connection")]),e._v(" object, you send data by calling its "),n("code",[e._v("send")]),e._v(" method:")]),e._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[e._v("connection"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("send")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[e._v("'data'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),n("p",[n("code",[e._v("send")]),e._v(" actually returns a Promise (for more "),n("code",[e._v("Bytes")]),e._v("), which contains the ACK data\nfor this message.  For IBC, if anything but an empty "),n("code",[e._v("''")]),e._v(" ACK is needed, you must\nresolve the "),n("code",[e._v("onReceive")]),e._v(" returned Promise within the same block as the received\npacket message (i.e. it must not depend upon further input from the chain in order\nto resolve).  This restriction may be enforced differently or lifted for other\nnetwork implementations.")]),e._v(" "),n("p",[e._v("NOTE: The type of this data is currently a string.  Ideally we would also accept\nNode.js "),n("code",[e._v("Buffer")]),e._v(" objects, or Javascript "),n("code",[e._v("ArrayBuffer")]),e._v(" and "),n("code",[e._v("TypedArray")]),e._v(" objects,\nbut unfortunately neither can be serialized by our current inter-vat marshalling code.")]),e._v(" "),n("h2",{attrs:{id:"receiving-data-the-connectionhandler"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#receiving-data-the-connectionhandler"}},[e._v("#")]),e._v(" Receiving Data: The ConnectionHandler")]),e._v(" "),n("p",[e._v("You must provide each open connection with a "),n("code",[e._v("ConnectionHandler")]),e._v(" object, where\nyou write methods that will be called when various things happen to the connection.\nYou can share a single handler object between multiple connections, if you like,\nor you can make a separate one for each.")]),e._v(" "),n("p",[e._v("You can omit any of the methods and those events will simply be ignored. All these\nmethods include the Connection object as the first argument, and the "),n("code",[e._v("ConnectionHandler")]),e._v("\nitself as the last argument, which might help if you want to share a common handler\nfunction among multiple connections.")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("onOpen(connection, handler)")]),e._v(": this is called when the connection is established,\nwhich tells you that the remote end has successfully accepted the connection request")]),e._v(" "),n("li",[n("code",[e._v("onReceive(connection, packetBytes, handler)")]),e._v(": this is called each time the\nremote end sends a packet full of data")]),e._v(" "),n("li",[n("code",[e._v("onClose(connection, reason, handler)")]),e._v(": this is called when the connection is closed,\neither because one side wanted it to close, or because an error occurred")])]),e._v(" "),n("p",[e._v("The "),n("code",[e._v("reason")]),e._v(" in "),n("code",[e._v("onclose")]),e._v(" is optional, as in it may be "),n("code",[e._v("undefined")]),e._v(".")]),e._v(" "),n("p",[n("code",[e._v("onReceive")]),e._v(" is the most important method. Each time the remote end sends a packet,\nyour "),n("code",[e._v("onReceive")]),e._v(" method will be called with the data inside that packet (currently\nas a String, but ideally as an ArrayBuffer with a custom "),n("code",[e._v(".toString()")]),e._v(" method with\nan optional "),n("code",[e._v("encoding")]),e._v(" argument (default "),n("code",[e._v("'latin1'")]),e._v("), so that it can contain\narbitrary bytes).")]),e._v(" "),n("p",[e._v("The return value of "),n("code",[e._v("onReceive")]),e._v(" is nominally a Promise for the ACK data of the\nmessage (and should thus appear as the eventual resolution of the Promise returned\nby "),n("code",[e._v("connection.send()")]),e._v(" on the other side). However the ACK data can only appear in\nthe block which includes the transaction that delivered the message, so there is a\nlimited time window during which this data can be successfully delivered, and there\nis no guarantee that "),n("code",[e._v("onReceive")]),e._v(" will return a Promise that resolves in time.  If\nthe promise does not resolve in time, the implementation will automatically send\nan empty "),n("code",[e._v("''")]),e._v(" ACK.  Because ACKs with data in them are difficult for your handler\nto get right, it is better to avoid them, where possible.")]),e._v(" "),n("h2",{attrs:{id:"closing-the-connection"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#closing-the-connection"}},[e._v("#")]),e._v(" Closing the Connection")]),e._v(" "),n("p",[e._v("When a given Connection ceases to be useful, you should close it:")]),e._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[e._v("connection"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("close")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),n("p",[e._v("This initiates a shutdown. The "),n("code",[e._v("ConnectionHandler")]),e._v(" on both sides will eventually\nsee their "),n("code",[e._v("onClose()")]),e._v(" methods be called, with a "),n("code",[e._v("reason")]),e._v(".  It allows them to\ndistinguish an intentional "),n("code",[e._v("onClose()")]),e._v(" ("),n("code",[e._v("reason")]),e._v(" is "),n("code",[e._v("undefined")]),e._v(") from some error\ncondition.")]),e._v(" "),n("h2",{attrs:{id:"removing-a-listener"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#removing-a-listener"}},[e._v("#")]),e._v(" Removing a Listener")]),e._v(" "),n("p",[e._v("When you no longer wish to receive connections on a port, you can remove the listener:")]),e._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[e._v("port"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("removeListener")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("handler"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("then")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" console"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("log")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[e._v("'removed'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),n("p",[e._v("You must provide the handler you added, to enable the future ability to have\nmultiple listeners on the same port.")]),e._v(" "),n("p",[e._v("Note that if you want to listen on this port again, you can just\ncall "),n("code",[e._v("port.addListener(...)")]),e._v(", as before.  If you want to start a new connection,\nyou can always call "),n("code",[e._v("port.connect(...)")]),e._v(".")]),e._v(" "),n("h3",{attrs:{id:"closing-the-port-entirely"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#closing-the-port-entirely"}},[e._v("#")]),e._v(" Closing the Port Entirely")]),e._v(" "),n("p",[e._v("Removing a listener doesn't release the port address to make it available\nfor other "),n("code",[e._v("bind")]),e._v(" requests.  You can call:")]),e._v(" "),n("div",{staticClass:"language-js extra-class"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[e._v("port"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("revoke")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),n("p",[e._v("to completely deallocate the port, remove all listeners, close all pending\nconnections, and release its address.")]),e._v(" "),n("p",[n("strong",[e._v("CAUTION:")]),e._v(" Be aware that if you call "),n("code",[e._v("home.ibcport[0]~.revoke()")]),e._v(", it will be\nuseless for new "),n("code",[e._v(".connect")]),e._v(" or "),n("code",[e._v(".addListener")]),e._v(" attempts.  You will need to provision\na new Agoric client via https://testnet.agoric.com/ to obtain a new setup with a\nfunctioning "),n("code",[e._v("home.ibcport")]),e._v(".")])])}),[],!1,null,null,null);t.default=o.exports}}]);